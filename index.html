<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>HSM Schedule → Calendar</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>

<style>
  body { font-family: -apple-system, BlinkMacSystemFont, sans-serif; padding: 18px; text-align: center; }
  h2 { margin: 8px 0 0; }
  .sub { color: #555; margin: 6px 0 18px; font-size: 14px; }

  button, a.dl {
    display: inline-block;
    padding: 14px; font-size: 16px; width: 100%;
    margin-top: 12px; border-radius: 12px; border: none;
    background-color: #007AFF; color: white; font-weight: 600;
    text-decoration: none;
    text-align: center;
    box-sizing: border-box;
  }
  a.dl { background-color: #34C759; }

  input[type="file"] { margin-top: 14px; width: 100%; }
  input[type="date"] {
    width: 100%; padding: 12px; font-size: 16px;
    border-radius: 12px; border: 1px solid #ccc;
    margin-top: 10px;
    box-sizing: border-box;
  }

  .card { margin-top: 14px; padding: 14px; border-radius: 14px; background: #f2f2f7; text-align: left; }
  .err { background: #ffecec; }
  .warn { background: #fff4dd; }
  .small { color:#666; font-size: 13px; margin-top: 6px; white-space: pre-wrap; }
  .pill { display:inline-block; padding: 4px 10px; border-radius: 999px; background:#e8e8ed; font-size: 12px; margin-right: 8px; }
  hr { border:none; border-top:1px solid #ddd; margin:12px 0; }
</style>
</head>

<body>
<h2>HSM Schedule → Calendar</h2>
<div class="sub">Upload PDF • Finds all BRAWER events • Generates one .ics</div>

<input type="file" id="pdfUpload" accept="application/pdf">

<div id="dateFallback" style="display:none;">
  <div class="card warn">
    <strong>Couldn’t auto-detect the schedule date.</strong>
    <div class="small">Select the date below, then press “Generate .ics” again.</div>
    <input type="date" id="manualDate" />
  </div>
</div>

<button id="goBtn" onclick="processPDF()">Generate .ics</button>

<div id="result"></div>

<script>
pdfjsLib.GlobalWorkerOptions.workerSrc =
  "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js";

const LAST_NAME = "BRAWER";

// ---------- helpers ----------
function normalizeSpaces(s){
  return String(s).replace(/\u00A0/g, " ").replace(/\s+/g, " ").trim();
}
function yBucket(y){ return Math.round(y / 5) * 5; }
function isValidTime(t){ return /^[0-2]\d[0-5]\d$/.test(t); }
function uniqBy(arr, keyFn){
  const seen = new Set(); const out = [];
  for (const x of arr){ const k = keyFn(x); if (!seen.has(k)) { seen.add(k); out.push(x); } }
  return out;
}
function escapeICS(s){
  return String(s)
    .replace(/\\/g, "\\\\")
    .replace(/\n/g, "\\n")
    .replace(/,/g, "\\,")
    .replace(/;/g, "\\;");
}
function formatICSDate(dateObj, hhmm){
  const y = dateObj.getFullYear();
  const m = String(dateObj.getMonth()+1).padStart(2,'0');
  const d = String(dateObj.getDate()).padStart(2,'0');
  return `${y}${m}${d}T${hhmm}00`;
}
function guessType(rowText){
  const t = rowText.toUpperCase();
  if (t.includes("OFT") || t.includes("WTT") || t.includes("TOFT") || t.includes("SIM")) return "SIM";
  if (t.includes("ICW") || t.includes("CAI") || t.includes("IGR") || t.includes("IMATT") || t.includes("CRT") || t.includes("EXAM") || t.includes("LAB")) return "CLASS";
  return "FLT";
}
function showDownloadLink(icsText){
  const blob = new Blob([icsText], { type: "text/calendar" });
  const url = URL.createObjectURL(blob);
  return `<a class="dl" href="${url}" download="hsm_schedule.ics">Download .ics</a>`;
}

// ---------- date parsing ----------
function tryExtractDateFromDATE(pageText){
  const t = normalizeSpaces(pageText).toUpperCase();
  const m = t.match(/DATE:\s*(\d{1,2})\s*([A-Z](?:\s*[A-Z]){2}|[A-Z]{3})\s*(\d{4})/);
  if (!m) return null;

  const day = parseInt(m[1], 10);
  const mon = String(m[2]).toUpperCase().replace(/[^A-Z]/g, "");
  const year = parseInt(m[3], 10);

  const months = { JAN:0, FEB:1, MAR:2, APR:3, MAY:4, JUN:5, JUL:6, AUG:7, SEP:8, OCT:9, NOV:10, DEC:11 };
  if (!(mon in months)) return null;

  return new Date(year, months[mon], day, 12, 0, 0);
}
function tryExtractDateFromJULIAN(pageText){
  const t = normalizeSpaces(pageText).toUpperCase();
  const m = t.match(/JULIAN:\s*(\d{4})/);
  if (!m) return null;

  const jul = m[1];
  const yDigit = parseInt(jul[0], 10);
  const doy = parseInt(jul.slice(1), 10);
  if (!Number.isFinite(yDigit) || !Number.isFinite(doy) || doy < 1 || doy > 366) return null;

  const now = new Date();
  const currentYear = now.getFullYear();
  const decadeBase = Math.floor(currentYear / 10) * 10;

  const c1 = decadeBase + yDigit;
  const c2 = decadeBase - 10 + yDigit;
  const c3 = decadeBase + 10 + yDigit;

  const dist = (y) => Math.abs(y - currentYear);
  let year = c1;
  if (dist(c2) < dist(year)) year = c2;
  if (dist(c3) < dist(year)) year = c3;

  const d = new Date(year, 0, 1, 12, 0, 0);
  d.setDate(d.getDate() + (doy - 1));
  return d;
}
function getManualDate(){
  const el = document.getElementById("manualDate");
  if (!el || !el.value) return null;
  const [yy, mm, dd] = el.value.split("-");
  const y = parseInt(yy, 10), m = parseInt(mm, 10), d = parseInt(dd, 10);
  if (!y || !m || !d) return null;
  return new Date(y, m - 1, d, 12, 0, 0);
}

// ---------- time extraction nearest your name ----------
// We only ever WANT times closest to "... BRAWER" to avoid grabbing other nearby times.
function extractTimesWithPositions(text){
  const out = [];
  const re = /\b\d{4}\b/g;
  let m;
  while ((m = re.exec(text)) !== null){
    const t = m[0];
    if (isValidTime(t)) out.push({ t, idx: m.index });
  }
  return out;
}

function pickTimesNearestName(text, nameUpper, count){
  const upper = text.toUpperCase();
  const nameIdx = upper.lastIndexOf(nameUpper);
  if (nameIdx === -1) return [];

  const times = extractTimesWithPositions(text);
  if (!times.length) return [];

  // Prefer times that appear BEFORE the name (most skeds end with instructor)
  const before = times.filter(x => x.idx < nameIdx);
  const candidates = before.length ? before : times;

  // Sort by distance to name, then keep closest N, then sort chronologically by position
  const closest = candidates
    .map(x => ({...x, dist: Math.abs(nameIdx - x.idx)}))
    .sort((a,b) => a.dist - b.dist)
    .slice(0, count)
    .sort((a,b) => a.idx - b.idx)
    .map(x => x.t);

  return closest;
}

// ---------- parse row ----------
function parseRowToEvent(rowText, fallbackContextText){
  // rowText is ALWAYS the row containing BRAWER (this is what you want in NOTES)
  const type = guessType(rowText);

  // First try to extract times from the row itself (best case)
  let times = pickTimesNearestName(rowText, LAST_NAME, 3);

  // If not enough times (PDF split line), borrow from fallbackContextText,
  // but STILL keep NOTES as rowText, and pick times nearest the name there too.
  if (times.length < 2 && fallbackContextText){
    const borrowed = pickTimesNearestName(fallbackContextText, LAST_NAME, 3);
    if (borrowed.length > times.length) times = borrowed;
  }

  // SIM/FLT: need 3 times (BRF ETD ETA)
  if (times.length >= 3){
    const brf = times[0];
    const eta = times[2];

    const evtNumMatch = rowText.match(/^\s*(\d+)\s+/);
    const evtNumber = evtNumMatch ? evtNumMatch[1] : "";

    const nameMatch = rowText.match(/^\s*\d+\s+(.*?)(?=\s+\d{4}\b)/);
    const evtName = nameMatch ? nameMatch[1].trim() : "Event";

    return {
      summary: `${type} ${evtNumber} – ${evtName}`.replace(/\s+/g," ").trim(),
      description: rowText,        // EXACTLY the row containing your name
      start: brf,
      end: eta
    };
  }

  // CLASS/Ground: need 2 times (START END)
  if (times.length === 2){
    // Keep title short/clean; notes will have the full row line
    const shortTitle = rowText.length > 50 ? rowText.slice(0, 50).trim() + "…" : rowText;

    return {
      summary: `CLASS – ${shortTitle}`,
      description: rowText,        // EXACTLY the row containing your name
      start: times[0],
      end: times[1]
    };
  }

  return null;
}

// ---------- main ----------
async function processPDF(){
  const resultEl = document.getElementById("result");
  const fallbackEl = document.getElementById("dateFallback");
  const goBtn = document.getElementById("goBtn");

  resultEl.innerHTML = "";
  goBtn.disabled = true;

  try {
    const fileInput = document.getElementById("pdfUpload");
    if (!fileInput.files.length){
      alert("Upload the schedule PDF.");
      return;
    }

    const file = fileInput.files[0];
    const arrayBuffer = await file.arrayBuffer();
    const pdf = await pdfjsLib.getDocument({data: arrayBuffer}).promise;

    let scheduleDate = null;
    let events = [];

    for (let p = 1; p <= pdf.numPages; p++){
      const page = await pdf.getPage(p);
      const content = await page.getTextContent();
      const pageText = content.items.map(i => i.str).join(" ");

      if (!scheduleDate){
        scheduleDate = tryExtractDateFromDATE(pageText) || tryExtractDateFromJULIAN(pageText);
      }

      // Build rows keyed by y, keep y + text
      const rows = {};
      for (const item of content.items){
        const y = yBucket(item.transform[5]);
        if (!rows[y]) rows[y] = [];
        rows[y].push(item);
      }

      const rowList = Object.keys(rows)
        .map(k => parseInt(k,10))
        .sort((a,b) => b - a)
        .map(y => {
          const text = normalizeSpaces(
            rows[y].sort((a,b)=>a.transform[4]-b.transform[4]).map(i=>i.str).join(" ")
          );
          return { y, text };
        });

      // Only rows that contain your name are eligible.
      for (let i = 0; i < rowList.length; i++){
        const row = rowList[i].text;
        if (!row.toUpperCase().includes(LAST_NAME)) continue;

        // Context text is row + very near neighbors to borrow times if the row got split
        const y0 = rowList[i].y;
        const context = rowList
          .filter(r => Math.abs(r.y - y0) <= 10)
          .map(r => r.text)
          .filter(t => t.length)
          .join(" ")
          .replace(/\s+/g, " ")
          .trim();

        const evt = parseRowToEvent(row, context);
        if (evt) events.push(evt);
      }
    }

    // Date handling (manual fallback)
    if (!scheduleDate){
      fallbackEl.style.display = "block";
      const manual = getManualDate();
      if (!manual){
        resultEl.innerHTML =
          `<div class="card err">
            <strong>Could not parse schedule DATE/JULIAN.</strong>
            <div class="small">Select the date above, then press “Generate .ics” again.</div>
          </div>`;
        return;
      }
      scheduleDate = manual;
    } else {
      fallbackEl.style.display = "none";
    }

    // Dedup
    events = uniqBy(events, e => `${e.summary}|${e.start}|${e.end}|${e.description}`);

    if (!events.length){
      resultEl.innerHTML =
        `<div class="card err">
          <strong>No events parsed for ${LAST_NAME}.</strong>
        </div>`;
      return;
    }

    // Build ICS
    let ics = "BEGIN:VCALENDAR\nVERSION:2.0\n";
    for (const e of events){
      ics += "BEGIN:VEVENT\n";
      ics += `SUMMARY:${escapeICS(e.summary)}\n`;
      ics += `DTSTART:${formatICSDate(scheduleDate, e.start)}\n`;
      ics += `DTEND:${formatICSDate(scheduleDate, e.end)}\n`;
      ics += `DESCRIPTION:${escapeICS(e.description)}\n`;
      ics += "END:VEVENT\n";
    }
    ics += "END:VCALENDAR";

    // Preview + download
    const dateLabel = scheduleDate.toDateString();
    let html = `<div class="card">
      <div><span class="pill">${dateLabel}</span><span class="pill">${events.length} event(s)</span></div>
      <div class="small">Tap to download:</div>
      ${showDownloadLink(ics)}
      <hr>
    `;
    for (const e of events){
      html += `<div style="margin-bottom:10px;">
        <div><strong>${e.summary}</strong></div>
        <div class="small">${e.start}–${e.end}</div>
        <div class="small">Notes: ${e.description}</div>
      </div>`;
    }
    html += `</div>`;
    resultEl.innerHTML = html;

  } catch (err) {
    resultEl.innerHTML =
      `<div class="card err">
        <strong>Something crashed while parsing.</strong>
        <div class="small">${escapeICS(err && err.stack ? err.stack : String(err))}</div>
      </div>`;
  } finally {
    goBtn.disabled = false;
  }
}
</script>

</body>
</html>
