<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>HSM Schedule → Calendar</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>

<style>
  body { font-family: -apple-system, BlinkMacSystemFont, sans-serif; padding: 18px; text-align: center; }
  h2 { margin: 8px 0 0; }
  .sub { color: #555; margin: 6px 0 18px; font-size: 14px; }
  button {
    padding: 14px; font-size: 16px; width: 100%;
    margin-top: 12px; border-radius: 12px; border: none;
    background-color: #007AFF; color: white; font-weight: 600;
  }
  input[type="file"] { margin-top: 14px; width: 100%; }
  input[type="date"] {
    width: 100%; padding: 12px; font-size: 16px;
    border-radius: 12px; border: 1px solid #ccc;
    margin-top: 10px;
  }
  .card { margin-top: 14px; padding: 14px; border-radius: 14px; background: #f2f2f7; text-align: left; }
  .err { background: #ffecec; }
  .warn { background: #fff4dd; }
  .small { color:#666; font-size: 13px; margin-top: 6px; }
  .pill { display:inline-block; padding: 4px 10px; border-radius: 999px; background:#e8e8ed; font-size: 12px; margin-right: 8px; }
  hr { border:none; border-top:1px solid #ddd; margin:12px 0; }
</style>
</head>

<body>
<h2>HSM Schedule → Calendar</h2>
<div class="sub">Upload PDF • Finds all BRAWER events • Downloads one .ics</div>

<input type="file" id="pdfUpload" accept="application/pdf">

<div id="dateFallback" style="display:none;">
  <div class="card warn">
    <strong>Couldn’t auto-detect the schedule date.</strong>
    <div class="small">Confirm/edit the date below, then press “Generate .ics” again.</div>
    <input type="date" id="manualDate" />
  </div>
</div>

<button onclick="processPDF()">Generate .ics</button>

<div id="result"></div>

<script>
const LAST_NAME = "BRAWER";

// ---------- helpers ----------
function normalizeSpaces(s){
  return String(s).replace(/\u00A0/g, " ").replace(/\s+/g, " ").trim();
}

function yBucket(y){ return Math.round(y / 3) * 3; }
function isValidTime(t){ return /^[0-2]\d[0-5]\d$/.test(t); }

function uniqBy(arr, keyFn){
  const seen = new Set();
  const out = [];
  for (const x of arr){
    const k = keyFn(x);
    if (!seen.has(k)){ seen.add(k); out.push(x); }
  }
  return out;
}

function escapeICS(s){
  return String(s)
    .replace(/\\/g, "\\\\")
    .replace(/\n/g, "\\n")
    .replace(/,/g, "\\,")
    .replace(/;/g, "\\;");
}

// Floating local time; imports cleanly on iOS
function formatICSDate(dateObj, hhmm){
  const y = dateObj.getFullYear();
  const m = String(dateObj.getMonth()+1).padStart(2,'0');
  const d = String(dateObj.getDate()).padStart(2,'0');
  return `${y}${m}${d}T${hhmm}00`;
}

function downloadICS(content){
  const blob = new Blob([content], { type: "text/calendar" });
  const link = document.createElement("a");
  link.href = URL.createObjectURL(blob);
  link.download = "hsm_schedule.ics";
  link.click();
}

function guessType(rowText){
  const t = rowText.toUpperCase();
  if (t.includes("OFT") || t.includes("WTT") || t.includes("TOFT") || t.includes("SIM")) return "SIM";
  if (t.includes("ICW") || t.includes("CAI") || t.includes("IGR") || t.includes("IMATT") || t.includes("CRT") || t.includes("EXAM") || t.includes("LAB")) return "CLASS";
  return "FLT";
}

// ---------- DATE parsing ----------
function tryExtractDateFromDATE(pageText){
  const t = normalizeSpaces(pageText).toUpperCase();
  // Allow FEB with weird spacing like F E B
  const m = t.match(/DATE:\s*(\d{1,2})\s*([A-Z](?:\s*[A-Z]){2}|[A-Z]{3})\s*(\d{4})/);
  if (!m) return null;

  const day = parseInt(m[1], 10);
  const mon = String(m[2]).toUpperCase().replace(/[^A-Z]/g, "");
  const year = parseInt(m[3], 10);

  const months = { JAN:0, FEB:1, MAR:2, APR:3, MAY:4, JUN:5, JUL:6, AUG:7, SEP:8, OCT:9, NOV:10, DEC:11 };
  if (!(mon in months)) return null;

  return new Date(year, months[mon], day, 12, 0, 0);
}

// JULIAN parsing. Format is YDDD (e.g., 6044 for 13 FEB 2026).
function tryExtractDateFromJULIAN(pageText){
  const t = normalizeSpaces(pageText).toUpperCase();
  const m = t.match(/JULIAN:\s*(\d{4})/);
  if (!m) return null;

  const jul = m[1];     // e.g. "6044"
  const yDigit = parseInt(jul[0], 10);
  const doy = parseInt(jul.slice(1), 10); // 044

  if (!Number.isFinite(yDigit) || !Number.isFinite(doy) || doy < 1 || doy > 366) return null;

  const now = new Date();
  const currentYear = now.getFullYear();
  const decadeBase = Math.floor(currentYear / 10) * 10;

  const candidate1 = decadeBase + yDigit;
  const candidate2 = decadeBase - 10 + yDigit;
  const candidate3 = decadeBase + 10 + yDigit;

  function dist(y){ return Math.abs(y - currentYear); }
  let year = candidate1;
  if (dist(candidate2) < dist(year)) year = candidate2;
  if (dist(candidate3) < dist(year)) year = candidate3;

  const d = new Date(year, 0, 1, 12, 0, 0);
  d.setDate(d.getDate() + (doy - 1));
  return d;
}

function getManualDateIfSet(){
  const el = document.getElementById("manualDate");
  if (!el || !el.value) return null;
  const [yy, mm, dd] = el.value.split("-");
  const y = parseInt(yy, 10), m = parseInt(mm, 10), d = parseInt(dd, 10);
  if (!y || !m || !d) return null;
  return new Date(y, m - 1, d, 12, 0, 0);
}

function setManualDateDefaultToTomorrowIfEmpty(){
  const el = document.getElementById("manualDate");
  if (!el) return;
  if (el.value) return; // don't overwrite if user already set it

  const t = new Date();
  t.setDate(t.getDate() + 1);

  // input[type=date] expects YYYY-MM-DD
  const yyyy = t.getFullYear();
  const mm = String(t.getMonth() + 1).padStart(2, "0");
  const dd = String(t.getDate()).padStart(2, "0");
  el.value = `${yyyy}-${mm}-${dd}`;
}

// ---------- main ----------
async function processPDF(){
  const resultEl = document.getElementById("result");
  resultEl.innerHTML = "";

  const fileInput = document.getElementById("pdfUpload");
  if (!fileInput.files.length){
    alert("Upload the schedule PDF.");
    return;
  }

  const file = fileInput.files[0];
  const arrayBuffer = await file.arrayBuffer();
  const pdf = await pdfjsLib.getDocument({data: arrayBuffer}).promise;

  let scheduleDate = null;
  let candidates = [];

  for (let p = 1; p <= pdf.numPages; p++){
    const page = await pdf.getPage(p);
    const content = await page.getTextContent();

    if (!scheduleDate){
      const pageText = content.items.map(i => i.str).join(" ");
      scheduleDate = tryExtractDateFromDATE(pageText) || tryExtractDateFromJULIAN(pageText);
    }

    const rows = {};
    for (const item of content.items){
      const y = yBucket(item.transform[5]);
      if (!rows[y]) rows[y] = [];
      rows[y].push(item);
    }

    for (const y of Object.keys(rows)){
      const rowText = normalizeSpaces(
        rows[y].sort((a,b)=>a.transform[4]-b.transform[4]).map(i=>i.str).join(" ")
      );

      if (rowText.toUpperCase().includes(LAST_NAME)){
        candidates.push(rowText);
      }
    }
  }

  // Manual fallback if both DATE and JULIAN failed
  if (!scheduleDate){
    document.getElementById("dateFallback").style.display = "block";
    setManualDateDefaultToTomorrowIfEmpty();

    const manual = getManualDateIfSet();
    if (!manual){
      resultEl.innerHTML =
        `<div class="card err">
          <strong>Could not parse schedule DATE or JULIAN.</strong>
          <div class="small">Confirm/edit the date above, then press “Generate .ics” again.</div>
        </div>`;
      return;
    }
    scheduleDate = manual;
  } else {
    document.getElementById("dateFallback").style.display = "none";
  }

  if (!candidates.length){
    resultEl.innerHTML =
      `<div class="card err">
        <strong>No rows found for ${LAST_NAME}.</strong>
      </div>`;
    return;
  }

  // Extract events
  let events = [];

  for (const row of candidates){
    const times = (row.match(/\b\d{4}\b/g) || []).filter(isValidTime);

    // SIM/FLT style rows: BRF ETD ETA
    if (times.length >= 3){
      const brf = times[0];
      const eta = times[2];

      const evtNumMatch = row.match(/^\s*(\d+)\s+/);
      const evtNumber = evtNumMatch ? evtNumMatch[1] : "";

      const nameMatch = row.match(/^\s*\d+\s+(.*?)(?=\s+\d{4}\b)/);
      const evtName = nameMatch ? nameMatch[1].trim() : "Event";

      const type = guessType(row);

      events.push({
        summary: `${type} ${evtNumber} – ${evtName}`.replace(/\s+/g," ").trim(),
        description: row,
        start: brf,
        end: eta
      });
      continue;
    }

    // CLASS/ground style: 0700-1300
    const rangeMatch = row.match(/\b(\d{4})\s*-\s*(\d{4})\b/);
    if (rangeMatch && isValidTime(rangeMatch[1]) && isValidTime(rangeMatch[2])){
      events.push({
        summary: `CLASS – ${row.substring(0, 70)}${row.length > 70 ? "..." : ""}`,
        description: row,
        start: rangeMatch[1],
        end: rangeMatch[2]
      });
    }
  }

  events = uniqBy(events, e => `${e.summary}|${e.start}|${e.end}`);

  if (!events.length){
    resultEl.innerHTML =
      `<div class="card err">
        <strong>Found your name, but couldn’t parse any times.</strong>
      </div>`;
    return;
  }

  // Build one ICS with all events
  let ics = "BEGIN:VCALENDAR\nVERSION:2.0\n";
  for (const e of events){
    ics += "BEGIN:VEVENT\n";
    ics += `SUMMARY:${escapeICS(e.summary)}\n`;
    ics += `DTSTART:${formatICSDate(scheduleDate, e.start)}\n`;
    ics += `DTEND:${formatICSDate(scheduleDate, e.end)}\n`;
    ics += `DESCRIPTION:${escapeICS(e.description)}\n`;
    ics += "END:VEVENT\n";
  }
  ics += "END:VCALENDAR";

  downloadICS(ics);

  // Preview list
  const dateLabel = scheduleDate.toDateString();
  let html = `<div class="card">
    <div><span class="pill">${dateLabel}</span><span class="pill">${events.length} event(s)</span></div>
    <div class="small">Downloaded: <strong>hsm_schedule.ics</strong></div>
    <hr>
  `;
  for (const e of events){
    html += `<div style="margin-bottom:10px;">
      <div><strong>${e.summary}</strong></div>
      <div class="small">${e.start}–${e.end}</div>
    </div>`;
  }
  html += `</div>`;
  resultEl.innerHTML = html;
}

// Nice touch: if the picker becomes visible, prefill tomorrow immediately
document.addEventListener("DOMContentLoaded", () => {
  setManualDateDefaultToTomorrowIfEmpty();
});
</script>

</body>
</html>
