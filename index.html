<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>HSM Schedule → Calendar</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>

<style>
  body { font-family: -apple-system, BlinkMacSystemFont, sans-serif; padding: 18px; text-align: center; }
  h2 { margin: 8px 0 0; }
  .sub { color: #555; margin: 6px 0 18px; font-size: 14px; }

  button, a.dl {
    display: inline-block;
    padding: 14px; font-size: 16px; width: 100%;
    margin-top: 12px; border-radius: 12px; border: none;
    background-color: #007AFF; color: white; font-weight: 600;
    text-decoration: none;
    text-align: center;
    box-sizing: border-box;
  }
  a.dl { background-color: #34C759; }

  input[type="file"] { margin-top: 14px; width: 100%; }
  input[type="date"] {
    width: 100%; padding: 12px; font-size: 16px;
    border-radius: 12px; border: 1px solid #ccc;
    margin-top: 10px;
    box-sizing: border-box;
  }

  .card { margin-top: 14px; padding: 14px; border-radius: 14px; background: #f2f2f7; text-align: left; }
  .err { background: #ffecec; }
  .warn { background: #fff4dd; }
  .small { color:#666; font-size: 13px; margin-top: 6px; white-space: pre-wrap; }
  .pill { display:inline-block; padding: 4px 10px; border-radius: 999px; background:#e8e8ed; font-size: 12px; margin-right: 8px; }
  hr { border:none; border-top:1px solid #ddd; margin:12px 0; }
</style>
</head>

<body>
<h2>HSM Schedule → Calendar</h2>
<div class="sub">Upload PDF • Finds all BRAWER events • Generates one .ics</div>

<input type="file" id="pdfUpload" accept="application/pdf">

<div id="dateFallback" style="display:none;">
  <div class="card warn">
    <strong>Couldn’t auto-detect the schedule date.</strong>
    <div class="small">Confirm/edit the date below, then press “Generate .ics”.</div>
    <input type="date" id="manualDate" />
  </div>
</div>

<button id="goBtn" onclick="processPDF()">Generate .ics</button>

<div id="result"></div>

<script>
/** Ensure worker is set (prevents silent failures on some browsers) */
pdfjsLib.GlobalWorkerOptions.workerSrc =
  "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js";

const LAST_NAME = "BRAWER";

// ---------- helpers ----------
function normalizeSpaces(s){
  return String(s).replace(/\u00A0/g, " ").replace(/\s+/g, " ").trim();
}
function yBucket(y){ return Math.round(y / 3) * 3; }
function isValidTime(t){ return /^[0-2]\d[0-5]\d$/.test(t); }
function uniqBy(arr, keyFn){
  const seen = new Set(); const out = [];
  for (const x of arr){ const k = keyFn(x); if (!seen.has(k)) { seen.add(k); out.push(x); } }
  return out;
}
function escapeICS(s){
  return String(s)
    .replace(/\\/g, "\\\\")
    .replace(/\n/g, "\\n")
    .replace(/,/g, "\\,")
    .replace(/;/g, "\\;");
}
function formatICSDate(dateObj, hhmm){
  const y = dateObj.getFullYear();
  const m = String(dateObj.getMonth()+1).padStart(2,'0');
  const d = String(dateObj.getDate()).padStart(2,'0');
  return `${y}${m}${d}T${hhmm}00`;
}
function guessType(rowText){
  const t = rowText.toUpperCase();
  if (t.includes("OFT") || t.includes("WTT") || t.includes("TOFT") || t.includes("SIM")) return "SIM";
  if (t.includes("ICW") || t.includes("CAI") || t.includes("IGR") || t.includes("IMATT") || t.includes("CRT") || t.includes("EXAM") || t.includes("LAB")) return "CLASS";
  return "FLT";
}

// ---------- date parsing ----------
function tryExtractDateFromDATE(pageText){
  const t = normalizeSpaces(pageText).toUpperCase();
  const m = t.match(/DATE:\s*(\d{1,2})\s*([A-Z](?:\s*[A-Z]){2}|[A-Z]{3})\s*(\d{4})/);
  if (!m) return null;

  const day = parseInt(m[1], 10);
  const mon = String(m[2]).toUpperCase().replace(/[^A-Z]/g, "");
  const year = parseInt(m[3], 10);

  const months = { JAN:0, FEB:1, MAR:2, APR:3, MAY:4, JUN:5, JUL:6, AUG:7, SEP:8, OCT:9, NOV:10, DEC:11 };
  if (!(mon in months)) return null;

  return new Date(year, months[mon], day, 12, 0, 0);
}

function tryExtractDateFromJULIAN(pageText){
  const t = normalizeSpaces(pageText).toUpperCase();
  const m = t.match(/JULIAN:\s*(\d{4})/);
  if (!m) return null;

  const jul = m[1];          // e.g. 6044
  const yDigit = parseInt(jul[0], 10);
  const doy = parseInt(jul.slice(1), 10);

  if (!Number.isFinite(yDigit) || !Number.isFinite(doy) || doy < 1 || doy > 366) return null;

  const now = new Date();
  const currentYear = now.getFullYear();
  const decadeBase = Math.floor(currentYear / 10) * 10;

  const c1 = decadeBase + yDigit;
  const c2 = decadeBase - 10 + yDigit;
  const c3 = decadeBase + 10 + yDigit;

  const dist = (y) => Math.abs(y - currentYear);
  let year = c1;
  if (dist(c2) < dist(year)) year = c2;
  if (dist(c3) < dist(year)) year = c3;

  const d = new Date(year, 0, 1, 12, 0, 0);
  d.setDate(d.getDate() + (doy - 1));
  return d;
}

function setManualDateDefaultToTomorrowIfEmpty(){
  const el = document.getElementById("manualDate");
  if (!el || el.value) return;

  const t = new Date();
  t.setDate(t.getDate() + 1);

  const yyyy = t.getFullYear();
  const mm = String(t.getMonth() + 1).padStart(2, "0");
  const dd = String(t.getDate()).padStart(2, "0");
  el.value = `${yyyy}-${mm}-${dd}`;
}

function getManualDate(){
  const el = document.getElementById("manualDate");
  if (!el) return null;

  // If the picker isn't visible yet, still allow a value if it exists
  if (!el.value) return null;

  const parts = el.value.split("-");
  if (parts.length !== 3) return null;

  const y = parseInt(parts[0], 10);
  const m = parseInt(parts[1], 10);
  const d = parseInt(parts[2], 10);
  if (!y || !m || !d) return null;

  return new Date(y, m - 1, d, 12, 0, 0);
}

function showDownloadLink(icsText){
  const blob = new Blob([icsText], { type: "text/calendar" });
  const url = URL.createObjectURL(blob);

  // Return a link the user can tap (reliable everywhere)
  return `<a class="dl" href="${url}" download="hsm_schedule.ics">Download .ics</a>`;
}

// ---------- main ----------
async function processPDF(){
  const resultEl = document.getElementById("result");
  const fallbackEl = document.getElementById("dateFallback");
  const goBtn = document.getElementById("goBtn");

  resultEl.innerHTML = "";
  goBtn.disabled = true;

  try {
    const fileInput = document.getElementById("pdfUpload");
    if (!fileInput.files.length){
      alert("Upload the schedule PDF.");
      return;
    }

    const file = fileInput.files[0];
    const arrayBuffer = await file.arrayBuffer();
    const pdf = await pdfjsLib.getDocument({data: arrayBuffer}).promise;

    let scheduleDate = null;
    let candidates = [];

    for (let p = 1; p <= pdf.numPages; p++){
      const page = await pdf.getPage(p);
      const content = await page.getTextContent();
      const pageText = content.items.map(i => i.str).join(" ");

      if (!scheduleDate){
        scheduleDate = tryExtractDateFromDATE(pageText) || tryExtractDateFromJULIAN(pageText);
      }

      // Row reconstruction by y-position
      const rows = {};
      for (const item of content.items){
        const y = yBucket(item.transform[5]);
        if (!rows[y]) rows[y] = [];
        rows[y].push(item);
      }

      for (const y of Object.keys(rows)){
        const rowText = normalizeSpaces(
          rows[y].sort((a,b)=>a.transform[4]-b.transform[4]).map(i=>i.str).join(" ")
        );

        if (rowText.toUpperCase().includes(LAST_NAME)){
          candidates.push(rowText);
        }
      }
    }

    // If auto-date failed, enable manual picker and ALSO proceed if the user has picked a date
    if (!scheduleDate){
      fallbackEl.style.display = "block";
      setManualDateDefaultToTomorrowIfEmpty();

      const manual = getManualDate();
      if (manual){
        scheduleDate = manual; // proceed on same click
      } else {
        resultEl.innerHTML =
          `<div class="card err">
            <strong>Could not parse schedule DATE/JULIAN.</strong>
            <div class="small">Pick/confirm the date above, then press “Generate .ics”.</div>
          </div>`;
        return;
      }
    } else {
      fallbackEl.style.display = "none";
    }

    if (!candidates.length){
      resultEl.innerHTML =
        `<div class="card err">
          <strong>No rows found for ${LAST_NAME}.</strong>
        </div>`;
      return;
    }

    // Extract events
    let events = [];

    for (const row of candidates){
      const times = (row.match(/\b\d{4}\b/g) || []).filter(isValidTime);

      // SIM/FLT style rows: BRF ETD ETA
      if (times.length >= 3){
        const brf = times[0];
        const eta = times[2];

        const evtNumMatch = row.match(/^\s*(\d+)\s+/);
        const evtNumber = evtNumMatch ? evtNumMatch[1] : "";

        const nameMatch = row.match(/^\s*\d+\s+(.*?)(?=\s+\d{4}\b)/);
        const evtName = nameMatch ? nameMatch[1].trim() : "Event";

        const type = guessType(row);

        events.push({
          summary: `${type} ${evtNumber} – ${evtName}`.replace(/\s+/g," ").trim(),
          description: row,
          start: brf,
          end: eta
        });
        continue;
      }

      // CLASS/ground events: exactly 2 times (more robust than relying on hyphen)
      if (times.length === 2){
        events.push({
          summary: `CLASS – ${row.substring(0, 70)}${row.length > 70 ? "..." : ""}`,
          description: row,
          start: times[0],
          end: times[1]
        });
        continue;
      }
    }

    events = uniqBy(events, e => `${e.summary}|${e.start}|${e.end}`);

    if (!events.length){
      resultEl.innerHTML =
        `<div class="card err">
          <strong>Found your name, but couldn’t parse any times.</strong>
        </div>`;
      return;
    }

    // Build ICS
    let ics = "BEGIN:VCALENDAR\nVERSION:2.0\n";
    for (const e of events){
      ics += "BEGIN:VEVENT\n";
      ics += `SUMMARY:${escapeICS(e.summary)}\n`;
      ics += `DTSTART:${formatICSDate(scheduleDate, e.start)}\n`;
      ics += `DTEND:${formatICSDate(scheduleDate, e.end)}\n`;
      ics += `DESCRIPTION:${escapeICS(e.description)}\n`;
      ics += "END:VEVENT\n";
    }
    ics += "END:VCALENDAR";

    // Show a reliable download link (and try auto-download too)
    const dateLabel = scheduleDate.toDateString();
    let html = `<div class="card">
      <div><span class="pill">${dateLabel}</span><span class="pill">${events.length} event(s)</span></div>
      <div class="small">If the download doesn’t start automatically, tap the button below.</div>
      ${showDownloadLink(ics)}
      <hr>
    `;
    for (const e of events){
      html += `<div style="margin-bottom:10px;">
        <div><strong>${e.summary}</strong></div>
        <div class="small">${e.start}–${e.end}</div>
      </div>`;
    }
    html += `</div>`;
    resultEl.innerHTML = html;

    // Best-effort auto download (some browsers block it; link above always works)
    try {
      const blob = new Blob([ics], { type: "text/calendar" });
      const link = document.createElement("a");
      link.href = URL.createObjectURL(blob);
      link.download = "hsm_schedule.ics";
      link.click();
    } catch (_) {}

  } catch (err) {
    resultEl.innerHTML =
      `<div class="card err">
        <strong>Something crashed while parsing.</strong>
        <div class="small">${escapeICS(err && err.stack ? err.stack : String(err))}</div>
      </div>`;
  } finally {
    goBtn.disabled = false;
  }
}

// Prefill manual date to tomorrow so if auto-parse fails, it’s already filled
document.addEventListener("DOMContentLoaded", () => {
  setManualDateDefaultToTomorrowIfEmpty();
});
</script>

</body>
</html>
